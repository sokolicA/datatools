% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/DataFrame.R, R/sugar.R
\name{DataFrame}
\alias{DataFrame}
\alias{DF}
\title{DataFrame Class}
\usage{
DF(tbl, key = NULL, id = NULL)
}
\arguments{
\item{tbl}{An object of class \code{data.frame}.}

\item{key}{Optional vector of column names. Setting a key sorts the table in RAM using the values of the key column(s). See Details.}

\item{id}{Optional ID of the object. Not currently used.}
}
\value{
A \code{DataFrame} object.
}
\description{
A wrapper class for tabular data objects of class \code{data.frame}.
}
\details{
The key parameter is passed to \code{data.table::setkey(key)}. If the parameter is not passed, the existing keys of \code{x} (if any) will be kept.
}
\section{Functions}{
\itemize{
\item \code{DF()}: DataFrame$new() constructor sugar

}}
\examples{

## ------------------------------------------------
## Method `DataFrame$head`
## ------------------------------------------------

   df <- DF(data.table(a=1:5, b=1:5))
   df$head(1)

## ------------------------------------------------
## Method `DataFrame$tail`
## ------------------------------------------------

   df <- DF(data.table(a=1:5, b=1:5))
   df$tail(1)

## ------------------------------------------------
## Method `DataFrame$sort`
## ------------------------------------------------

   df <- DF(data.table(a=1:5, b=1:5))
   df$sort(-b)

## ------------------------------------------------
## Method `DataFrame$is_key_unique`
## ------------------------------------------------

df <- DataFrame$new(data.table(a=1:5, b=1:5), key = c("a"))
df$is_key_unique()
df <- DataFrame$new(data.table(a=1:5, b=1:5))
df$is_key_unique()

## ------------------------------------------------
## Method `DataFrame$count`
## ------------------------------------------------

df <- DataFrame$new(data.table(a=1:5, b=1:5))
df$count()
df <- DataFrame$new(data.table(a=c(1,1,1,2,3), b=1:5))
df$count(by = list(a)) # df$count(by = .(a))

## ------------------------------------------------
## Method `DataFrame$update`
## ------------------------------------------------

   df <- DF(data.table(a=1:5, b=1:5))
   df$update(.(a = 2), b == 3)
   df$update(list(g = a, dd = ifelse(a==2, b, 0)), 1:2)

## ------------------------------------------------
## Method `DataFrame$update_join`
## ------------------------------------------------

df <- DF(data.table(x = 1:3, y = LETTERS[1:3], z = LETTERS[9:11], v=1:3))
y <- data.table(x = LETTERS[3:4], y = c(1, 2), z = LETTERS[6:7])
rel <- Rel(right=y)$on(x = y) # same as Relationship$new(right=y)$on(x = y)
df$update_join(rel, columns=list(a=3, c=ifelse(i.x == 1, 3, 2), z)) #i.x is from the table stored in df
df$update_join(rel, columns=list(g=c**2), where=x \%in\% 1:2)

## ------------------------------------------------
## Method `DataFrame$transform`
## ------------------------------------------------

   df <- DF(data.table(a=1:5, b=1:5))
   df$transform(.(a, b), function(x) x*2, b\%\%2==0)
   df$transform(! .names \%in\% c("a"), function(x) x*2, b>2)
   df$transform(! grepl("^a", .names), function(x) x*2, a != 1 & a > b)

## ------------------------------------------------
## Method `DataFrame$transform_if`
## ------------------------------------------------

    df <- DF(data.table(a=1:5, b=1:5, c = paste0("  ", 1:5, "   ")))
    df$transform_if(is.numeric, function(x) x*2)
    df$transform_if(is.character, trimws)

## ------------------------------------------------
## Method `DataFrame$filter`
## ------------------------------------------------

df <- DataFrame$new(data.table(a=1:5, b=1:5))
df$filter(a > 2)
df$filter(c(1, 3, 5))
df$filter(c(TRUE, NA, FALSE, FALSE, TRUE))

## ------------------------------------------------
## Method `DataFrame$filter_`
## ------------------------------------------------

df <- DataFrame$new(data.table(a=1:5, b=1:5))
df$filter_(a > 2)
df

## ------------------------------------------------
## Method `DataFrame$remove`
## ------------------------------------------------

df <- DataFrame$new(data.table(a=1:5, b=1:5))
df$remove(a > 2)
df <- DataFrame$new(data.table(a=1:5, b=1:5))
df$remove(c(1, 3, 5))
df <- DataFrame$new(data.table(a=1:3, b=1:3))
df$remove(c(TRUE, NA, FALSE))

## ------------------------------------------------
## Method `DataFrame$left_join`
## ------------------------------------------------

df <- DF(data.table(x = 1:3, y = LETTERS[1:3], z = LETTERS[9:11], v=1:3))
y <- data.table(x = LETTERS[3:4], y = c(1, 2), z = LETTERS[6:7])
rel <- Rel(right=y)$on(x = y) # same as Relationship$new(right=y)$on(x = y)
df$left_join(rel, add=.(a=3, c=ifelse(i.x==1, 3, 2), z, d=x)) #i.x is from the table stored in df

## ------------------------------------------------
## Method `DataFrame$append`
## ------------------------------------------------

x <- data.table(a=1:5, b=1:5)
y <- data.table(a=1:5, b=1:5)
df <- DataFrame$new(x)
res <- df$append(y, x, y)
df <- DF(data.table(a=1, b=2), key="a")

}
\section{Active bindings}{
\if{html}{\out{<div class="r6-active-bindings">}}
\describe{
\item{\code{columns}}{Column names object.}

\item{\code{key}}{Key getter}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-DataFrame-new}{\code{DataFrame$new()}}
\item \href{#method-DataFrame-print}{\code{DataFrame$print()}}
\item \href{#method-DataFrame-head}{\code{DataFrame$head()}}
\item \href{#method-DataFrame-tail}{\code{DataFrame$tail()}}
\item \href{#method-DataFrame-sort}{\code{DataFrame$sort()}}
\item \href{#method-DataFrame-is_key_unique}{\code{DataFrame$is_key_unique()}}
\item \href{#method-DataFrame-count}{\code{DataFrame$count()}}
\item \href{#method-DataFrame-update}{\code{DataFrame$update()}}
\item \href{#method-DataFrame-update_join}{\code{DataFrame$update_join()}}
\item \href{#method-DataFrame-transform}{\code{DataFrame$transform()}}
\item \href{#method-DataFrame-transform_if}{\code{DataFrame$transform_if()}}
\item \href{#method-DataFrame-filter}{\code{DataFrame$filter()}}
\item \href{#method-DataFrame-filter_}{\code{DataFrame$filter_()}}
\item \href{#method-DataFrame-remove}{\code{DataFrame$remove()}}
\item \href{#method-DataFrame-set_key}{\code{DataFrame$set_key()}}
\item \href{#method-DataFrame-left_join}{\code{DataFrame$left_join()}}
\item \href{#method-DataFrame-append}{\code{DataFrame$append()}}
\item \href{#method-DataFrame-unwrap}{\code{DataFrame$unwrap()}}
\item \href{#method-DataFrame-copy}{\code{DataFrame$copy()}}
\item \href{#method-DataFrame-clone}{\code{DataFrame$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-new"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-new}{}}}
\subsection{Method \code{new()}}{
\code{DataFrame} Constructor
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$new(tbl, key = NULL, id = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{tbl}}{An object of class \code{data.frame}.}

\item{\code{key}}{Optional vector of column names. Setting a key sorts the table in RAM using the values of the key column(s). See Details.}

\item{\code{id}}{Optional ID of the object. Not currently used.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-print"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-print}{}}}
\subsection{Method \code{print()}}{
Print the table object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$print()}\if{html}{\out{</div>}}
}

\subsection{Details}{
The method used is \code{print.data.table}.
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-head"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-head}{}}}
\subsection{Method \code{head()}}{
Return the first n rows.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$head(n = 5L)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{n}}{The number of rows to return. Defaults to 5.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new \code{DataFrame} object with only the first \code{n} rows.
For negative values of n, this method returns all rows except the last |n| rows.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{   df <- DF(data.table(a=1:5, b=1:5))
   df$head(1)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-tail"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-tail}{}}}
\subsection{Method \code{tail()}}{
Return the last n rows.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$tail(n = 5L)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{n}}{The number of rows to return. Defaults to 5.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new \code{DataFrame} object with only the first \code{n} rows.
For negative values of n, this method returns all rows except the first |n| rows.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{   df <- DF(data.table(a=1:5, b=1:5))
   df$tail(1)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-sort"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-sort}{}}}
\subsection{Method \code{sort()}}{
Sort the table rows
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$sort(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{The columns to sort by. Do not quote column names. See \code{?data.table::setorder}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Invisibly returns itself.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{   df <- DF(data.table(a=1:5, b=1:5))
   df$sort(-b)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-is_key_unique"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-is_key_unique}{}}}
\subsection{Method \code{is_key_unique()}}{
Check whether keys represent unique entries
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$is_key_unique()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
\code{TRUE} if the set key is unique and \code{FALSE} otherwise. If no key is set the result is \code{FALSE}.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{df <- DataFrame$new(data.table(a=1:5, b=1:5), key = c("a"))
df$is_key_unique()
df <- DataFrame$new(data.table(a=1:5, b=1:5))
df$is_key_unique()
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-count"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-count}{}}}
\subsection{Method \code{count()}}{
Count the number of rows.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$count(by = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{by}}{An optional list() specifying the columns to group by. Defaults to no grouping.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A data.table with the row counts in the \code{N} column.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{df <- DataFrame$new(data.table(a=1:5, b=1:5))
df$count()
df <- DataFrame$new(data.table(a=c(1,1,1,2,3), b=1:5))
df$count(by = list(a)) # df$count(by = .(a))
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-update"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-update}{}}}
\subsection{Method \code{update()}}{
Update table columns by reference.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$update(columns, where = NULL, by = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{columns}}{A list of columns to update or add and the corresponding calculation.}

\item{\code{where}}{Optional expression/integer vector/logical vector specifying which rows to update. Defaults to all rows.}

\item{\code{by}}{Optional list of columns to group by before performing the update. Defaults to no grouping.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Nothing.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{   df <- DF(data.table(a=1:5, b=1:5))
   df$update(.(a = 2), b == 3)
   df$update(list(g = a, dd = ifelse(a==2, b, 0)), 1:2)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-update_join"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-update_join}{}}}
\subsection{Method \code{update_join()}}{
Perform an update join.

Add new or update current table rows on matching positions.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$update_join(relationship, columns = NULL, where = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{relationship}}{A \code{Relationship} object with \code{right} table and \code{on} specified. See details.}

\item{\code{columns}}{List of column names to update and/or add. Defaults to \code{NULL} which adds all columns. Can also be transformations of columns. See details.}

\item{\code{where}}{Optional expression/integer vector/logical vector specifying which rows to update. Defaults to all rows.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
A \code{Relationship} object with a specified \code{right} table and \code{on} condition.
The \code{left} table of the relationship will be set to the current object's table.
This will override an existing \code{left} specification.
The \code{right} table is joined to the \code{left} (current) table based on the \code{on} condition.
Multiple Conditions provided in \code{on} have to be separated by commas. Also note that \code{on(x)} is the same as \code{on(x=x)}.

Using columns from the \code{left} (current) table in calculations provided in \code{add} can be done by
prefixing the column names with \strong{\code{i.}}. See examples.

Note that \code{list(...)} can be aliased with \code{.(...)} due to the background use of \code{data.table}.

The join will not be performed if there are multiple matches found in the \code{right} table.
In this case either use \code{left_join} or delete duplicated foreign keys in the \code{right} table.
}

\subsection{Returns}{
Returns the updated itself. Returns an error if there are multiple matches found in the \code{right} table.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{df <- DF(data.table(x = 1:3, y = LETTERS[1:3], z = LETTERS[9:11], v=1:3))
y <- data.table(x = LETTERS[3:4], y = c(1, 2), z = LETTERS[6:7])
rel <- Rel(right=y)$on(x = y) # same as Relationship$new(right=y)$on(x = y)
df$update_join(rel, columns=list(a=3, c=ifelse(i.x == 1, 3, 2), z)) #i.x is from the table stored in df
df$update_join(rel, columns=list(g=c**2), where=x \%in\% 1:2)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-transform"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-transform}{}}}
\subsection{Method \code{transform()}}{
Transform columns with function
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$transform(columns, fun, where = NULL, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{columns}}{Either a list of columns to transform or a function that evaluates to boolean with the column names as argument. See details.}

\item{\code{fun}}{A function that is applied to the selected columns.}

\item{\code{where}}{Optional expression/integer vector/logical vector specifying which rows to update. Defaults to all rows.}

\item{\code{...}}{Optional arguments that are passed to \code{fun}.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
If a function is passed as argument to \code{columns} it must be prefixed with en exclamation mark (\strong{\code{!}}) and the function's argument
that takes the column names must be aliased with \strong{\code{.names}}. See examples.
}

\subsection{Returns}{
Nothing.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{   df <- DF(data.table(a=1:5, b=1:5))
   df$transform(.(a, b), function(x) x*2, b\%\%2==0)
   df$transform(! .names \%in\% c("a"), function(x) x*2, b>2)
   df$transform(! grepl("^a", .names), function(x) x*2, a != 1 & a > b)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-transform_if"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-transform_if}{}}}
\subsection{Method \code{transform_if()}}{
Transform across columns with function
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$transform_if(predicate, fun, where = NULL, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{predicate}}{A function that is applied to the columns.  The variables for which \code{predicate} returns TRUE are selected.}

\item{\code{fun}}{A transformation function that is applied to the selected columns.}

\item{\code{where}}{Optional expression/integer vector/logical vector specifying which rows to update. Defaults to all rows.}

\item{\code{...}}{Optional arguments that are passed to \code{fun}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Nothing.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{    df <- DF(data.table(a=1:5, b=1:5, c = paste0("  ", 1:5, "   ")))
    df$transform_if(is.numeric, function(x) x*2)
    df$transform_if(is.character, trimws)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-filter"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-filter}{}}}
\subsection{Method \code{filter()}}{
Create a new \code{DataFrame} with filter applied to the rows.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$filter(keep)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{keep}}{An expression to be evaluated inside the table, integer vector specifying rows to remove or a logical vector. See details}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
\itemize{
\item If an expression is passed it will be evaluated inside the context of the table.
\item If an integer vector is passed, the rows specified will be kept. Passing duplicated numbers will result in duplicated rows and passing numbers larger than the number of rows will result in \code{NA} rows.
\item If a logical vector is passed it must be of the same length as the number of rows. Logical \code{NA} values are treated as \code{FALSE} and those rows will not be removed.
}
}

\subsection{Returns}{
A new \code{DataFrame} with kept rows.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{df <- DataFrame$new(data.table(a=1:5, b=1:5))
df$filter(a > 2)
df$filter(c(1, 3, 5))
df$filter(c(TRUE, NA, FALSE, FALSE, TRUE))
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-filter_"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-filter_}{}}}
\subsection{Method \code{filter_()}}{
Filter the table in place.

Same as \verb{$filter} method, just done in place. Opposite of the \verb{$remove} method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$filter_(keep)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{keep}}{An expression to be evaluated inside the table, integer vector specifying rows to remove or a logical vector. See details}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
\itemize{
\item If an expression is passed it will be evaluated inside the context of the table.
\item If an integer vector is passed, the rows specified will be kept. Passing duplicated numbers will result in duplicated rows and passing numbers larger than the number of rows will result in \code{NA} rows.
\item If a logical vector is passed it must be of the same length as the number of rows. Logical \code{NA} values are treated as \code{FALSE} and those rows will not be removed.
}
}

\subsection{Returns}{
Returns itself with kept rows only.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{df <- DataFrame$new(data.table(a=1:5, b=1:5))
df$filter_(a > 2)
df
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-remove"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-remove}{}}}
\subsection{Method \code{remove()}}{
Remove specified rows from the table in place.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$remove(where)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{where}}{An expression to be evaluated inside the table, integer vector specifying rows to remove or a logical vector. See details}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
\itemize{
\item If an expression is passed it will be evaluated inside the context of the table.
\item If an integer vector is passed, the rows specified will be removed. Passing duplicated numbers or numbers larger than the number of rows will result in an error.
\item If a logical vector is passed it must be of the same length as the number of rows. Logical \code{NA} values are treated as \code{FALSE} and those rows will not be removed.
}
}

\subsection{Returns}{
A \code{DataFrame} object consisting of removed rows.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{df <- DataFrame$new(data.table(a=1:5, b=1:5))
df$remove(a > 2)
df <- DataFrame$new(data.table(a=1:5, b=1:5))
df$remove(c(1, 3, 5))
df <- DataFrame$new(data.table(a=1:3, b=1:3))
df$remove(c(TRUE, NA, FALSE))
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-set_key"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-set_key}{}}}
\subsection{Method \code{set_key()}}{
Create a key the table.

\code{set_key} sorts the table and marks it as sorted with an attribute sorted.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$set_key(key)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{key}}{A Character vector of column names to set the key on.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-left_join"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-left_join}{}}}
\subsection{Method \code{left_join()}}{
Perform a left outer join
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$left_join(relationship, add = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{relationship}}{A \code{Relationship} object with \code{right} table and \code{on} specified. See details.}

\item{\code{add}}{Optional list of column names to add. Defaults to \code{NULL} which adds all columns. Can also be transformations of columns. See details.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
A \code{Relationship} object with a specified \code{right} table and \code{on} condition.
The \code{left} table of the relationship will be set to the current object's table.
This will override an existing \code{left} specification.
The \code{right} table is joined to the \code{left} (current) table based on the \code{on} condition.
Multiple Conditions provided in \code{on} have to be separated by commas. Also note that \code{on(x)} is the same as \code{on(x=x)}.

Using columns from the \code{left} (current) table in calculations provided in \code{add} can be done by
prefixing the column names with \code{i.}. See examples.

Note that \code{list(...)} can be aliased with \code{.(...)} due to the background use of \code{data.table}.
}

\subsection{Returns}{
A new (keyed) \code{DataFrame} object extended with the columns from the joined table.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{df <- DF(data.table(x = 1:3, y = LETTERS[1:3], z = LETTERS[9:11], v=1:3))
y <- data.table(x = LETTERS[3:4], y = c(1, 2), z = LETTERS[6:7])
rel <- Rel(right=y)$on(x = y) # same as Relationship$new(right=y)$on(x = y)
df$left_join(rel, add=.(a=3, c=ifelse(i.x==1, 3, 2), z, d=x)) #i.x is from the table stored in df
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-append"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-append}{}}}
\subsection{Method \code{append()}}{
Create a new \code{DataFrame} by appending tables using column names.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$append(..., fill = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{Objects of class \code{data.frame}.}

\item{\code{fill}}{Optional parameter whether to fill missing columns with \code{NA}. Defaults to \code{FALSE}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new unkeyed \code{DataFrame} object with rows appended.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{x <- data.table(a=1:5, b=1:5)
y <- data.table(a=1:5, b=1:5)
df <- DataFrame$new(x)
res <- df$append(y, x, y)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-unwrap"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-unwrap}{}}}
\subsection{Method \code{unwrap()}}{
Get the underlying data.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$unwrap()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
The underlying \code{data.table} object.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-copy"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-copy}{}}}
\subsection{Method \code{copy()}}{
Create a deep copy
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$copy()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A copy of the \code{DataFrame}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-clone"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
