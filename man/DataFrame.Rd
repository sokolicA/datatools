% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/DataFrame.R, R/sugar.R
\name{DataFrame}
\alias{DataFrame}
\alias{DF}
\title{DataFrame Class}
\usage{
DF(tbl, key = NULL)
}
\arguments{
\item{tbl}{An object of class \code{data.frame}.}

\item{key}{Optional vector of column names. Setting a key sorts the table in RAM using the values of the key column(s). See Details.}
}
\value{
A \code{DataFrame} object.
}
\description{
A wrapper class for tabular data objects of class \code{data.frame}.
}
\details{
The key parameter is passed to \code{data.table::setkey(key)}. If the parameter is not passed, the existing keys of \code{x} (if any) will be kept.
}
\section{Functions}{
\itemize{
\item \code{DF()}: DataFrame$new() constructor sugar

}}
\examples{

## ------------------------------------------------
## Method `DataFrame$head`
## ------------------------------------------------

   df <- DF(data.frame(a=1:5, b=1:5))
   df$head(1)

## ------------------------------------------------
## Method `DataFrame$tail`
## ------------------------------------------------

   df <- DF(data.frame(a=1:5, b=1:5))
   df$tail(1)

## ------------------------------------------------
## Method `DataFrame$sort`
## ------------------------------------------------

   df <- DF(data.frame(a=1:5, b=1:5))
   df$sort(-b)

## ------------------------------------------------
## Method `DataFrame$is_key_unique`
## ------------------------------------------------

df <- DF(data.frame(a=1:5, b=1:5), key = c("a"))
df$is_key_unique()
df <- DF(data.frame(a=1:5, b=1:5))
df$is_key_unique()

## ------------------------------------------------
## Method `DataFrame$count`
## ------------------------------------------------

df <- DF(data.frame(x=1:5, g = c("a", "a", "b", "c", "c")))
df$count()
df$group_by(g)$count()

## ------------------------------------------------
## Method `DataFrame$filter`
## ------------------------------------------------

df <- DF(data.frame(a=1:5, b=1:5))
df$filter(a > 2)
df$filter(c(1, 3, 5))
df$filter(c(TRUE, NA, FALSE, FALSE, TRUE))

## ------------------------------------------------
## Method `DataFrame$filter_`
## ------------------------------------------------

df <- DF(data.frame(a=1:5, b=1:5))
df$filter_(a > 2)
df

## ------------------------------------------------
## Method `DataFrame$group_by`
## ------------------------------------------------

df <- DF(data.table(a=1:5, b=3))
df$group_by(a)
df$group_by("a")
df$group_by(a, b)
df$group_by(c("a", "b"))
df$group_by(a > 2)
df$group_by(s = a > 2) # will name the grouping column with s
a <- "b"
df$group_by(a) #will group by a
df$group_by(c(a)) # will group by b
df$group_by(NULL) # will remove grouping

## ------------------------------------------------
## Method `DataFrame$set`
## ------------------------------------------------

df <- DataFrame$new(data.table(a=1:3, b=1:3, d = LETTERS[1:3]))
df$select(is.character)$where(a==2)$set(a); df
df$where(a==2)$set(fifelse(a==3, 1, 0)); df
df$select(is.numeric)$set(NA); df


## ------------------------------------------------
## Method `DataFrame$is_grouped`
## ------------------------------------------------

df <- DF(data.table(a=1:5, b=3))
df$is_grouped()
df$group(a)$is_grouped()

## ------------------------------------------------
## Method `DataFrame$remove`
## ------------------------------------------------

df <- DF(data.frame(a=1:5, b=1:5))
df$remove(a > 2)
df <- DF(data.frame(a=1:5, b=1:5))
df$remove(c(1, 3, 5))
df <- DF(data.frame(a=1:3, b=1:3))
df$remove(c(TRUE, NA, FALSE))

## ------------------------------------------------
## Method `DataFrame$append`
## ------------------------------------------------

x <- data.frame(a=1:5, b=1:5)
y <- data.frame(a=1:5, b=1:5)
df <- DF(x)
res <- df$append(y, x, y, df)

## ------------------------------------------------
## Method `DataFrame$append_`
## ------------------------------------------------

x <- data.frame(a=1:5, b=1:5)
y <- data.frame(a=1:5, b=1:5)
df <- DF(x)
df$append_(y, x, y, df)

df <- DF(data.table(a=1, b=2), key="a")

}
\section{Active bindings}{
\if{html}{\out{<div class="r6-active-bindings">}}
\describe{
\item{\code{columns}}{Column names object.}

\item{\code{key}}{Key getter.}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-DataFrame-new}{\code{DataFrame$new()}}
\item \href{#method-DataFrame-print}{\code{DataFrame$print()}}
\item \href{#method-DataFrame-head}{\code{DataFrame$head()}}
\item \href{#method-DataFrame-tail}{\code{DataFrame$tail()}}
\item \href{#method-DataFrame-sort}{\code{DataFrame$sort()}}
\item \href{#method-DataFrame-is_key_unique}{\code{DataFrame$is_key_unique()}}
\item \href{#method-DataFrame-count}{\code{DataFrame$count()}}
\item \href{#method-DataFrame-filter}{\code{DataFrame$filter()}}
\item \href{#method-DataFrame-filter_}{\code{DataFrame$filter_()}}
\item \href{#method-DataFrame-group_by}{\code{DataFrame$group_by()}}
\item \href{#method-DataFrame-where}{\code{DataFrame$where()}}
\item \href{#method-DataFrame-select}{\code{DataFrame$select()}}
\item \href{#method-DataFrame-set}{\code{DataFrame$set()}}
\item \href{#method-DataFrame-is_grouped}{\code{DataFrame$is_grouped()}}
\item \href{#method-DataFrame-remove}{\code{DataFrame$remove()}}
\item \href{#method-DataFrame-set_key}{\code{DataFrame$set_key()}}
\item \href{#method-DataFrame-append}{\code{DataFrame$append()}}
\item \href{#method-DataFrame-append_}{\code{DataFrame$append_()}}
\item \href{#method-DataFrame-unwrap}{\code{DataFrame$unwrap()}}
\item \href{#method-DataFrame-clone}{\code{DataFrame$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-new"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-new}{}}}
\subsection{Method \code{new()}}{
\code{DataFrame} Constructor
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$new(tbl, key = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{tbl}}{An object of class \code{data.frame}.}

\item{\code{key}}{Optional vector of column names. Setting a key sorts the table in RAM using the values of the key column(s). See Details.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-print"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-print}{}}}
\subsection{Method \code{print()}}{
Print the table object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$print()}\if{html}{\out{</div>}}
}

\subsection{Details}{
The method used is \code{print.data.table}.
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-head"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-head}{}}}
\subsection{Method \code{head()}}{
Return the first n rows.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$head(n = 5L)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{n}}{The number of rows to return. Defaults to 5.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new \code{DataFrame} object with only the first \code{n} rows.
For negative values of n, this method returns all rows except the last |n| rows.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{   df <- DF(data.frame(a=1:5, b=1:5))
   df$head(1)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-tail"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-tail}{}}}
\subsection{Method \code{tail()}}{
Return the last n rows.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$tail(n = 5L)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{n}}{The number of rows to return. Defaults to 5.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new \code{DataFrame} object with only the first \code{n} rows.
For negative values of n, this method returns all rows except the first |n| rows.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{   df <- DF(data.frame(a=1:5, b=1:5))
   df$tail(1)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-sort"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-sort}{}}}
\subsection{Method \code{sort()}}{
Sort the table rows
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$sort(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{The columns to sort by. Do not quote column names. See \code{?data.table::setorder}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Invisibly returns itself.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{   df <- DF(data.frame(a=1:5, b=1:5))
   df$sort(-b)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-is_key_unique"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-is_key_unique}{}}}
\subsection{Method \code{is_key_unique()}}{
Check whether keys represent unique entries
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$is_key_unique()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
\code{TRUE} if the set key is unique and \code{FALSE} otherwise. If no key is set the result is \code{FALSE}.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{df <- DF(data.frame(a=1:5, b=1:5), key = c("a"))
df$is_key_unique()
df <- DF(data.frame(a=1:5, b=1:5))
df$is_key_unique()
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-count"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-count}{}}}
\subsection{Method \code{count()}}{
Count the number of rows.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$count()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A \code{DataFrame} with the row counts. The result will be keyed by the grouping if a grouped \code{DataFrame} was used.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{df <- DF(data.frame(x=1:5, g = c("a", "a", "b", "c", "c")))
df$count()
df$group_by(g)$count()
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-filter"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-filter}{}}}
\subsection{Method \code{filter()}}{
Create a new \code{DataFrame} with filter applied to the rows.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$filter(keep)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{keep}}{An expression to be evaluated inside the table, integer vector specifying rows to remove or a logical vector. See details}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
\itemize{
\item If an expression is passed it will be evaluated inside the context of the table.
\item If an integer vector is passed, the rows specified will be kept. Passing duplicated numbers will result in duplicated rows and passing numbers larger than the number of rows will result in \code{NA} rows.
\item If a logical vector is passed it must be of the same length as the number of rows. Logical \code{NA} values are treated as \code{FALSE} and those rows will not be removed.
}
}

\subsection{Returns}{
A new \code{DataFrame} with kept rows.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{df <- DF(data.frame(a=1:5, b=1:5))
df$filter(a > 2)
df$filter(c(1, 3, 5))
df$filter(c(TRUE, NA, FALSE, FALSE, TRUE))
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-filter_"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-filter_}{}}}
\subsection{Method \code{filter_()}}{
Filter the table in place.

Same as \verb{$filter} method, just done in place. Opposite of the \verb{$remove} method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$filter_(keep)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{keep}}{An expression to be evaluated inside the table, integer vector specifying rows to remove or a logical vector. See details}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
\itemize{
\item If an expression is passed it will be evaluated inside the context of the table.
\item If an integer vector is passed, the rows specified will be kept. Passing duplicated numbers will result in duplicated rows and passing numbers larger than the number of rows will result in \code{NA} rows.
\item If a logical vector is passed it must be of the same length as the number of rows. Logical \code{NA} values are treated as \code{FALSE} and those rows will not be removed.
}
}

\subsection{Returns}{
Returns itself with kept rows only.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{df <- DF(data.frame(a=1:5, b=1:5))
df$filter_(a > 2)
df
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-group_by"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-group_by}{}}}
\subsection{Method \code{group_by()}}{
Group or un-group the data.
Used in calculation of statistics.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$group_by(..., persist = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{An expression specifying by what to group the data. See details.}

\item{\code{persist}}{Optional parameter whether the grouping should persist after the first evaluation. Defaults to FALSE.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Setting by Will override existing grouping without warning.
Pass a character vector of groups \code{vec} using \code{c(vec)}.
Set to \code{NULL} to remove any existing grouping.
}

\subsection{Returns}{
Invisibly returns itself.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{df <- DF(data.table(a=1:5, b=3))
df$group_by(a)
df$group_by("a")
df$group_by(a, b)
df$group_by(c("a", "b"))
df$group_by(a > 2)
df$group_by(s = a > 2) # will name the grouping column with s
a <- "b"
df$group_by(a) #will group by a
df$group_by(c(a)) # will group by b
df$group_by(NULL) # will remove grouping
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-where"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-where}{}}}
\subsection{Method \code{where()}}{
Work (operate?) on a subset of rows.
Experimental. #TODO define how certain methods use the persist option
This method will not remove the rows from the data.
Selected data modifications or calculations will be based only on the selected subset of data.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$where(rows, persist = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{rows}}{An expression to be evaluated inside the table, integer vector specifying rows to remove or a logical vector.}

\item{\code{persist}}{Optional parameter whether the subset should persist after evaluation.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
If \code{rows} is missing or \code{NULL} then all rows will be used.
}

\subsection{Returns}{
Invisibly returns itself.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-select"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-select}{}}}
\subsection{Method \code{select()}}{
Work on a subset of the columns.
Experimental. #TODO define behaviour of other methods.
This method will not remove the columns from the data.
Selected data modifications or calculations will be based only on the selected subset of data.

$select(mean(x) >5) --> df\link{, .SD, .SDcols = sapply(df, function(x) mean(x) > 5)}
$select(mean(is.na(x)) >0.2) --> df\link{, .SD, .SDcols = sapply(df, function(x) mean(x) > 5)}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$select(columns, persist = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{columns}}{May be character column names or numeric positions. See details.}

\item{\code{persist}}{Whether the subset should persist after  evaluation.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
The form startcol:endcol is also allowed. Dropping the specified columns can be accomplished by prepending the argument with ! or -, e.g. .SDcols = !c('x', 'y').
See documentation of \code{.SDcols} in \code{?data.table::data.table} for more possibilities.
}

\subsection{Returns}{
Invisibly returns itself.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-set"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-set}{}}}
\subsection{Method \code{set()}}{
Set column values.
Experimental. #TODO define behaviour of other methods.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$set(value)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{value}}{Value to assign to the columns and rows specified by where.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
TO ADD
}

\subsection{Returns}{
Invisibly returns itself.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{df <- DataFrame$new(data.table(a=1:3, b=1:3, d = LETTERS[1:3]))
df$select(is.character)$where(a==2)$set(a); df
df$where(a==2)$set(fifelse(a==3, 1, 0)); df
df$select(is.numeric)$set(NA); df

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-is_grouped"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-is_grouped}{}}}
\subsection{Method \code{is_grouped()}}{
Check whether the data is grouped.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$is_grouped()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
TRUE or FALSE.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{df <- DF(data.table(a=1:5, b=3))
df$is_grouped()
df$group(a)$is_grouped()
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-remove"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-remove}{}}}
\subsection{Method \code{remove()}}{
Remove specified rows from the table in place.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$remove(where)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{where}}{An expression to be evaluated inside the table, integer vector specifying rows to remove or a logical vector. See details}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
\itemize{
\item If an expression is passed it will be evaluated inside the context of the table, treating columns as variables.
\item If an integer vector is passed, the rows specified will be removed. Passing duplicated numbers will return duplicated rows as removed. \code{NA} values are treated as \code{FALSE} and those rows will not be removed.
\item If a logical vector is passed it must be of the same length as the number of rows. \code{NA} values are treated as \code{FALSE} and those rows will not be removed.
}
}

\subsection{Returns}{
A \code{DataFrame} object consisting of removed rows.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{df <- DF(data.frame(a=1:5, b=1:5))
df$remove(a > 2)
df <- DF(data.frame(a=1:5, b=1:5))
df$remove(c(1, 3, 5))
df <- DF(data.frame(a=1:3, b=1:3))
df$remove(c(TRUE, NA, FALSE))
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-set_key"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-set_key}{}}}
\subsection{Method \code{set_key()}}{
Create a key the table.

\code{set_key} sorts the table and marks it as sorted with an attribute sorted.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$set_key(key)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{key}}{A Character vector of column names to set the key on.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Invisibly returns itself.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-append"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-append}{}}}
\subsection{Method \code{append()}}{
Create a new \code{DataFrame} by appending tables using column names.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$append(..., fill = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{Objects of class \code{data.frame} or \code{DataFrame}.}

\item{\code{fill}}{Optional parameter whether to fill missing columns with \code{NA}. Defaults to \code{FALSE}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new unkeyed \code{DataFrame} object with rows appended.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{x <- data.frame(a=1:5, b=1:5)
y <- data.frame(a=1:5, b=1:5)
df <- DF(x)
res <- df$append(y, x, y, df)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-append_"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-append_}{}}}
\subsection{Method \code{append_()}}{
Append tables to the \code{DataFrame}.
Same as the \verb{$append} method but without creating a new object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$append_(..., fill = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{Objects of class \code{data.frame} or \code{DataFrame}.}

\item{\code{fill}}{Optional parameter whether to fill missing columns with \code{NA}. Defaults to \code{FALSE}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Invisibly returns itself.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{x <- data.frame(a=1:5, b=1:5)
y <- data.frame(a=1:5, b=1:5)
df <- DF(x)
df$append_(y, x, y, df)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-unwrap"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-unwrap}{}}}
\subsection{Method \code{unwrap()}}{
Get the underlying data.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$unwrap()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
The underlying \code{data.table} object.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-clone"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
