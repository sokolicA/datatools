% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/DataFrame.R, R/sugar.R
\name{DataFrame}
\alias{DataFrame}
\alias{DF}
\title{DataFrame Class}
\usage{
DF(tbl, copy = FALSE, alias = NULL)
}
\arguments{
\item{tbl}{An object of class \code{data.frame}.}

\item{copy}{Optional argument specifying whether to wrap a copy of the passed object. Defaults to \code{FALSE}.}

\item{alias}{Optional alias of the DataFrame.}
}
\value{
A \code{DataFrame} object.
}
\description{
A wrapper class for tabular data objects of class \code{data.frame}.
}
\section{Functions}{
\itemize{
\item \code{DF()}: DataFrame$new() constructor sugar

}}
\examples{

## ------------------------------------------------
## Method `DataFrame$head`
## ------------------------------------------------

   df <- DF(data.frame(a=1:5, b=1:5))
   df$head(1)

## ------------------------------------------------
## Method `DataFrame$tail`
## ------------------------------------------------

   df <- DF(data.frame(a=1:5, b=1:5))
   df$tail(1)

## ------------------------------------------------
## Method `DataFrame$sort`
## ------------------------------------------------

   df <- DF(data.frame(a=1:5, b=1:5))
   df$sort(-b)

## ------------------------------------------------
## Method `DataFrame$is_key_unique`
## ------------------------------------------------

df <- DF(data.frame(a=1:5, b=1:5), key = c("a"))
df$is_key_unique()
df <- DF(data.frame(a=1:5, b=1:5))
df$is_key_unique()

## ------------------------------------------------
## Method `DataFrame$count`
## ------------------------------------------------

df <- DF(data.frame(x=1:5, g = c("a", "a", "b", "c", "c")))
df$count()
df$group_by(g)$count()

## ------------------------------------------------
## Method `DataFrame$filter`
## ------------------------------------------------

df <- DF(data.frame(a=1:5, b=1:5))
df$filter(a > 2)
df$filter(c(1, 3, 5))
df$filter(c(TRUE, NA, FALSE, FALSE, TRUE))

## ------------------------------------------------
## Method `DataFrame$filter_`
## ------------------------------------------------

df <- DF(data.frame(a=1:5, b=1:5))
df$filter_(a > 2)
df

## ------------------------------------------------
## Method `DataFrame$group_by`
## ------------------------------------------------

df <- DF(data.table(a=1:5, b=3))
df$group_by(a)
df$group_by("a")
df$group_by(a, b)
df$group_by(c("a", "b"))
df$group_by(a > 2)
df$group_by(s = a > 2) # will name the grouping column with s
a <- "b"
df$group_by(a) #will group by a
df$group_by(c(a)) # will group by b
df$group_by(NULL) # will remove grouping

## ------------------------------------------------
## Method `DataFrame$set`
## ------------------------------------------------

df <- DataFrame$new(data.table(a=1:3, b=1:3, d = LETTERS[1:3]))
df$select(is.character)$where(a==2)$set(a); df
df$where(a==2)$set(fifelse(a==3, 1, 0)); df
df$select(is.numeric)$set(NA); df


## ------------------------------------------------
## Method `DataFrame$transform`
## ------------------------------------------------

   df <- DF(data.frame(a=1:5, b=1:5, c=c(1:4, NA)))
   df$where(b>3)$select("a")$transform(function(x) x + 50)
   df$where(b>3)$select("c")$transform(mean, na.rm=T)

## ------------------------------------------------
## Method `DataFrame$update`
## ------------------------------------------------

   df <- DF(data.frame(a=1:5, b=1:5))
   df$update(a = 2)
   df$update(g = a, dd = ifelse(a==2, b, 0))

## ------------------------------------------------
## Method `DataFrame$update_join`
## ------------------------------------------------

x <- data.table(a=1:3, b = c("a", "b", "a"))
y <- data.table(a=c("b", "c", "a"), b = 5:7)
df <- DF(x)
df$update_join(y, .(b=a), insert="all")

## ------------------------------------------------
## Method `DataFrame$left_join`
## ------------------------------------------------

x <- data.table(a=1:3, b = c("a", "b", "a"))
y <- data.table(a=c("b", "c", "a"), b = 5:7)
df <- DF(x)
df$left_join(y, .(b=a))

## ------------------------------------------------
## Method `DataFrame$remove`
## ------------------------------------------------

df <- DF(data.frame(a=1:5, b=1:5))
df$remove(a > 2)
df <- DF(data.frame(a=1:5, b=1:5))
df$remove(c(1, 3, 5))
df <- DF(data.frame(a=1:3, b=1:3))
df$remove(c(TRUE, NA, FALSE))

## ------------------------------------------------
## Method `DataFrame$insert`
## ------------------------------------------------

#TODO add information about operations on groups - df$group_by(plate)$insert(test_1=mean(val[id=="CTRL"]))

## ------------------------------------------------
## Method `DataFrame$concat`
## ------------------------------------------------

x <- data.frame(a=1:5, b=1:5)
y <- data.frame(a=1:5, b=1:5)
df <- DF(x)
res <- df$concat(y, x, y, df)

## ------------------------------------------------
## Method `DataFrame$concat_`
## ------------------------------------------------

x <- data.frame(a=1:5, b=1:5)
y <- data.frame(a=1:5, b=1:5)
df <- DF(x)
df$concat_(y, x, y, df)


## ------------------------------------------------
## Method `DataFrame$aggregate`
## ------------------------------------------------

df <- DF(mtcars, copy=TRUE)
sum_squares <- function(x) sum(x**2)
df$aggregate(sum_squares(x), mean(x), sd(x))
df$aggregate(max(x), mean(x))
df$aggregate(mean(x), mean_na_rm = mean(x, na.rm=T))
df <- DF(data.table(a=1, b=2))

}
\section{Active bindings}{
\if{html}{\out{<div class="r6-active-bindings">}}
\describe{
\item{\code{columns}}{Column names object.}

\item{\code{key}}{Key getter.}

\item{\code{static}}{Static Information}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-DataFrame-new}{\code{DataFrame$new()}}
\item \href{#method-DataFrame-print}{\code{DataFrame$print()}}
\item \href{#method-DataFrame-head}{\code{DataFrame$head()}}
\item \href{#method-DataFrame-tail}{\code{DataFrame$tail()}}
\item \href{#method-DataFrame-sort}{\code{DataFrame$sort()}}
\item \href{#method-DataFrame-is_key_unique}{\code{DataFrame$is_key_unique()}}
\item \href{#method-DataFrame-count}{\code{DataFrame$count()}}
\item \href{#method-DataFrame-filter}{\code{DataFrame$filter()}}
\item \href{#method-DataFrame-filter_}{\code{DataFrame$filter_()}}
\item \href{#method-DataFrame-where}{\code{DataFrame$where()}}
\item \href{#method-DataFrame-select}{\code{DataFrame$select()}}
\item \href{#method-DataFrame-group_by}{\code{DataFrame$group_by()}}
\item \href{#method-DataFrame-set}{\code{DataFrame$set()}}
\item \href{#method-DataFrame-transform}{\code{DataFrame$transform()}}
\item \href{#method-DataFrame-update}{\code{DataFrame$update()}}
\item \href{#method-DataFrame-update_join}{\code{DataFrame$update_join()}}
\item \href{#method-DataFrame-left_join}{\code{DataFrame$left_join()}}
\item \href{#method-DataFrame-remove}{\code{DataFrame$remove()}}
\item \href{#method-DataFrame-insert}{\code{DataFrame$insert()}}
\item \href{#method-DataFrame-set_key}{\code{DataFrame$set_key()}}
\item \href{#method-DataFrame-concat}{\code{DataFrame$concat()}}
\item \href{#method-DataFrame-concat_}{\code{DataFrame$concat_()}}
\item \href{#method-DataFrame-aggregate}{\code{DataFrame$aggregate()}}
\item \href{#method-DataFrame-unwrap}{\code{DataFrame$unwrap()}}
\item \href{#method-DataFrame-new_eval}{\code{DataFrame$new_eval()}}
\item \href{#method-DataFrame-clone}{\code{DataFrame$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-new"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-new}{}}}
\subsection{Method \code{new()}}{
\code{DataFrame} Constructor
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$new(tbl, copy = FALSE, alias = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{tbl}}{An object of class \code{data.frame}.}

\item{\code{copy}}{Optional argument specifying whether to wrap a copy of the passed object. Defaults to \code{FALSE}.}

\item{\code{alias}}{Optional alias of the DataFrame.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
The table is not copied by default which improves speed and memory performance.
Potential drawback of not copying the table is the ability to modify the table 'in place' outside the wrapper, which results in modifying the wrapped table.
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-print"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-print}{}}}
\subsection{Method \code{print()}}{
Print the table object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$print()}\if{html}{\out{</div>}}
}

\subsection{Details}{
The method used is \code{print.data.table}.
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-head"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-head}{}}}
\subsection{Method \code{head()}}{
Return the first n rows.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$head(n = 5L)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{n}}{The number of rows to return. Defaults to 5.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new \code{DataFrame} object with only the first \code{n} rows.
For negative values of n, this method returns all rows except the last |n| rows.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{   df <- DF(data.frame(a=1:5, b=1:5))
   df$head(1)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-tail"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-tail}{}}}
\subsection{Method \code{tail()}}{
Return the last n rows.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$tail(n = 5L)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{n}}{The number of rows to return. Defaults to 5.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new \code{DataFrame} object with only the first \code{n} rows.
For negative values of n, this method returns all rows except the first |n| rows.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{   df <- DF(data.frame(a=1:5, b=1:5))
   df$tail(1)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-sort"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-sort}{}}}
\subsection{Method \code{sort()}}{
Sort the table rows
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$sort(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{The columns to sort by. Do not quote column names. See \code{?data.table::setorder}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Invisibly returns itself.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{   df <- DF(data.frame(a=1:5, b=1:5))
   df$sort(-b)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-is_key_unique"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-is_key_unique}{}}}
\subsection{Method \code{is_key_unique()}}{
Check whether keys represent unique entries
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$is_key_unique()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
\code{TRUE} if the set key is unique and \code{FALSE} otherwise. If no key is set the result is \code{FALSE}.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{df <- DF(data.frame(a=1:5, b=1:5), key = c("a"))
df$is_key_unique()
df <- DF(data.frame(a=1:5, b=1:5))
df$is_key_unique()
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-count"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-count}{}}}
\subsection{Method \code{count()}}{
Count the number of rows.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$count()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A \code{DataFrame} with the row counts. The result will be keyed by the grouping if a grouped \code{DataFrame} was used.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{df <- DF(data.frame(x=1:5, g = c("a", "a", "b", "c", "c")))
df$count()
df$group_by(g)$count()
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-filter"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-filter}{}}}
\subsection{Method \code{filter()}}{
Create a new \code{DataFrame} with filter applied to the rows.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$filter(keep)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{keep}}{An expression to be evaluated inside the table, integer vector specifying rows to remove or a logical vector. See details}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
\itemize{
\item If an expression is passed it will be evaluated inside the context of the table.
\item If an integer vector is passed, the rows specified will be kept. Passing duplicated numbers will result in duplicated rows and passing numbers larger than the number of rows will result in \code{NA} rows.
\item If a logical vector is passed it must be of the same length as the number of rows. Logical \code{NA} values are treated as \code{FALSE} and those rows will not be removed.
}
}

\subsection{Returns}{
A new \code{DataFrame} with kept rows.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{df <- DF(data.frame(a=1:5, b=1:5))
df$filter(a > 2)
df$filter(c(1, 3, 5))
df$filter(c(TRUE, NA, FALSE, FALSE, TRUE))
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-filter_"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-filter_}{}}}
\subsection{Method \code{filter_()}}{
Filter the table in place.

Same as \verb{$filter} method, just done in place. Opposite of the \verb{$remove} method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$filter_(keep)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{keep}}{An expression to be evaluated inside the table, integer vector specifying rows to remove or a logical vector. See details}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
\itemize{
\item If an expression is passed it will be evaluated inside the context of the table.
\item If an integer vector is passed, the rows specified will be kept. Passing duplicated numbers will result in duplicated rows and passing numbers larger than the number of rows will result in \code{NA} rows.
\item If a logical vector is passed it must be of the same length as the number of rows. Logical \code{NA} values are treated as \code{FALSE} and those rows will not be removed.
}
}

\subsection{Returns}{
Returns itself with kept rows only.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{df <- DF(data.frame(a=1:5, b=1:5))
df$filter_(a > 2)
df
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-where"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-where}{}}}
\subsection{Method \code{where()}}{
Work (operate?) on a subset of rows.
Experimental. #TODO define how certain methods use the persist option
This method will not remove the rows from the data.
Selected data modifications or calculations will be based only on the selected subset of data.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$where(rows, persist = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{rows}}{An expression to be evaluated inside the table, integer vector specifying rows to remove or a logical vector.}

\item{\code{persist}}{Optional parameter whether the subset should persist after evaluation.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
If \code{rows} is missing or \code{NULL} then all rows will be used.
}

\subsection{Returns}{
Invisibly returns itself.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-select"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-select}{}}}
\subsection{Method \code{select()}}{
Work on a subset of the columns.
Experimental. #TODO define behaviour of other methods.
This method will not remove the columns from the data.
Selected data modifications or calculations will be based only on the selected subset of data.

$select(mean(x) >5) --> df\link{, .SD, .SDcols = sapply(df, function(x) mean(x) > 5)}
$select(mean(is.na(x)) >0.2) --> df\link{, .SD, .SDcols = sapply(df, function(x) mean(x) > 5)}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$select(columns, persist = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{columns}}{May be character column names or numeric positions. See details.}

\item{\code{persist}}{Whether the subset should persist after  evaluation.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
The form startcol:endcol is also allowed. Dropping the specified columns can be accomplished by prepending the argument with ! or -, e.g. .SDcols = !c('x', 'y').
See documentation of \code{.SDcols} in \code{?data.table::data.table} for more possibilities.
}

\subsection{Returns}{
Invisibly returns itself.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-group_by"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-group_by}{}}}
\subsection{Method \code{group_by()}}{
Group or un-group the data.
Used in calculation of statistics.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$group_by(..., persist = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{An expression specifying by what to group the data. See details.}

\item{\code{persist}}{Optional parameter whether the grouping should persist after the first evaluation. Defaults to FALSE.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Setting by Will override existing grouping without warning.
Pass a character vector of groups \code{vec} using \code{c(vec)}.
Set to \code{NULL} to remove any existing grouping.
}

\subsection{Returns}{
Invisibly returns itself.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{df <- DF(data.table(a=1:5, b=3))
df$group_by(a)
df$group_by("a")
df$group_by(a, b)
df$group_by(c("a", "b"))
df$group_by(a > 2)
df$group_by(s = a > 2) # will name the grouping column with s
a <- "b"
df$group_by(a) #will group by a
df$group_by(c(a)) # will group by b
df$group_by(NULL) # will remove grouping
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-set"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-set}{}}}
\subsection{Method \code{set()}}{
Set column values.
Experimental. #TODO define behaviour of other methods.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$set(value)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{value}}{Value to assign to the columns and rows specified by where.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
TO ADD
}

\subsection{Returns}{
Invisibly returns itself.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{df <- DataFrame$new(data.table(a=1:3, b=1:3, d = LETTERS[1:3]))
df$select(is.character)$where(a==2)$set(a); df
df$where(a==2)$set(fifelse(a==3, 1, 0)); df
df$select(is.numeric)$set(NA); df

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-transform"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-transform}{}}}
\subsection{Method \code{transform()}}{
Transform columns with function
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$transform(fun, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{fun}}{A function that is applied to the selected columns.}

\item{\code{...}}{Optional arguments that are passed to \code{fun}.
#'}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Invisibly returns itself.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{   df <- DF(data.frame(a=1:5, b=1:5, c=c(1:4, NA)))
   df$where(b>3)$select("a")$transform(function(x) x + 50)
   df$where(b>3)$select("c")$transform(mean, na.rm=T)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-update"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-update}{}}}
\subsection{Method \code{update()}}{
Update table columns by reference.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$update(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{Columns to update and the corresponding calculation.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Invisibly returns itself.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{   df <- DF(data.frame(a=1:5, b=1:5))
   df$update(a = 2)
   df$update(g = a, dd = ifelse(a==2, b, 0))
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-update_join"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-update_join}{}}}
\subsection{Method \code{update_join()}}{
Perform an update join.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$update_join(other, on, insert = NULL, update = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{other}}{The other (right) \code{data.table}.}

\item{\code{on}}{The condition to join the tables on. Either an unnamed character vector c("a") or a named character vector c(a="b") or a list list(a).}

\item{\code{insert}}{Optional list specifying which columns to add. \code{NULL} (default) does not insert any. Use \code{'add'} to insert all columns from the other table that are not used for joining.}

\item{\code{update}}{Optional list specifying updates of existing columns. No updates are performed by default.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Using columns from the wrapped \code{data.table} table in calculations provided in \code{update} can be done by
prefixing the column names of the left table with \strong{\code{i.}}. See examples.

Note that \code{list(...)} can be aliased with \code{.(...)} due to the background use of \code{data.table}.

The join will not be performed if there are multiple matches found in the \code{other} table.
In such cases use either \code{left_join} or delete duplicated foreign keys in the \code{other} table.
}

\subsection{Returns}{
Invisibly returns the updated itself.

Returns an error if there are multiple matches found in the \code{other} table.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{x <- data.table(a=1:3, b = c("a", "b", "a"))
y <- data.table(a=c("b", "c", "a"), b = 5:7)
df <- DF(x)
df$update_join(y, .(b=a), insert="all")
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-left_join"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-left_join}{}}}
\subsection{Method \code{left_join()}}{
Perform a left (outer) join.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$left_join(other, on)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{other}}{The other (right) \code{data.table}.}

\item{\code{on}}{The condition to join the tables on. Either a...}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Note that \code{list(...)} can be aliased with \code{.(...)} due to the background use of \code{data.table}.
}

\subsection{Returns}{
A new \code{DataFrame} extended with columns from the other table.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{x <- data.table(a=1:3, b = c("a", "b", "a"))
y <- data.table(a=c("b", "c", "a"), b = 5:7)
df <- DF(x)
df$left_join(y, .(b=a))
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-remove"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-remove}{}}}
\subsection{Method \code{remove()}}{
Remove specified rows from the table in place.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$remove(where)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{where}}{An expression to be evaluated inside the table, integer vector specifying rows to remove or a logical vector. See details}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
\itemize{
\item If an expression is passed it will be evaluated inside the context of the table, treating columns as variables.
\item If an integer vector is passed, the rows specified will be removed. Passing duplicated numbers will return duplicated rows as removed. \code{NA} values are treated as \code{FALSE} and those rows will not be removed.
\item If a logical vector is passed it must be of the same length as the number of rows. \code{NA} values are treated as \code{FALSE} and those rows will not be removed.
}
}

\subsection{Returns}{
A \code{DataFrame} object consisting of removed rows.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{df <- DF(data.frame(a=1:5, b=1:5))
df$remove(a > 2)
df <- DF(data.frame(a=1:5, b=1:5))
df$remove(c(1, 3, 5))
df <- DF(data.frame(a=1:3, b=1:3))
df$remove(c(TRUE, NA, FALSE))
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-insert"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-insert}{}}}
\subsection{Method \code{insert()}}{
Insert columns to the \code{DataFrame}.

Experimental. Considerations:
This method will insert new columns by reference.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$insert(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{Columns to add.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
#'TO ADD
}

\subsection{Returns}{
Invisibly returns itself.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{#TODO add information about operations on groups - df$group_by(plate)$insert(test_1=mean(val[id=="CTRL"]))
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-set_key"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-set_key}{}}}
\subsection{Method \code{set_key()}}{
Create a key the table.

\code{set_key} sorts the table and marks it as sorted with an attribute sorted.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$set_key(key)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{key}}{A Character vector of column names to set the key on.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Invisibly returns itself.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-concat"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-concat}{}}}
\subsection{Method \code{concat()}}{
Create a new \code{DataFrame} by appending tables using column names.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$concat(..., fill = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{Objects of class \code{data.frame} or \code{DataFrame}.}

\item{\code{fill}}{Optional parameter whether to fill missing columns with \code{NA}. Defaults to \code{FALSE}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new unkeyed \code{DataFrame} object with rows appended.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{x <- data.frame(a=1:5, b=1:5)
y <- data.frame(a=1:5, b=1:5)
df <- DF(x)
res <- df$concat(y, x, y, df)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-concat_"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-concat_}{}}}
\subsection{Method \code{concat_()}}{
Concatenate the rows of the \code{DataFrame}.
Same as the \verb{$concat} method but without creating a new object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$concat_(..., fill = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{Objects of class \code{data.frame} or \code{DataFrame}.}

\item{\code{fill}}{Optional parameter whether to fill missing columns with \code{NA}. Defaults to \code{FALSE}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Invisibly returns itself.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{x <- data.frame(a=1:5, b=1:5)
y <- data.frame(a=1:5, b=1:5)
df <- DF(x)
df$concat_(y, x, y, df)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-aggregate"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-aggregate}{}}}
\subsection{Method \code{aggregate()}}{
Data aggregation
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$aggregate(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{Functions used to create an aggregate summary. See details.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
An additional column with the name of the function is added to the table.
Passing named arguments will result in using the names in the output. See examples.
}

\subsection{Returns}{
A \code{DataFrame}.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{df <- DF(mtcars, copy=TRUE)
sum_squares <- function(x) sum(x**2)
df$aggregate(sum_squares(x), mean(x), sd(x))
df$aggregate(max(x), mean(x))
df$aggregate(mean(x), mean_na_rm = mean(x, na.rm=T))
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-unwrap"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-unwrap}{}}}
\subsection{Method \code{unwrap()}}{
Get the underlying data.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$unwrap()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
The underlying \code{data.table} object.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-new_eval"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-new_eval}{}}}
\subsection{Method \code{new_eval()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$new_eval(reset = TRUE)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataFrame-clone"></a>}}
\if{latex}{\out{\hypertarget{method-DataFrame-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataFrame$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
